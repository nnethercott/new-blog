<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1"name=viewport><meta content="dark light"name=color-scheme><meta content=#ffffff name=theme-color media=(prefers-color-scheme:light)><meta content=#000000 name=theme-color media=(prefers-color-scheme:dark)><meta content=nostromo property=og:site_name><link href=/static/logo.png rel=icon><link href=/apple-touch-icon.png rel=apple-touch-icon><link href=/common.css rel=stylesheet><script>window.MathJax={tex:{packages:{"[+]":["ams"]},inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>Exploiting a 40 year-old design choice to speed up vector search - nostromo</title><meta content="Exploiting a 40 year-old design choice to speed up vector search"property=og:title><meta content="A while ago, I came across a post on reddit about a user’s experience speeding up the rav1d video decoder by 1%, which inspired me to try a similar trick to speed up sorting f32’s in my vector database."name=description><meta content=article property=og:type><link href=post.css rel=stylesheet><link href=feed.xml rel=alternate title=nostromo type=application/atom+xml></head><body><header><a href=/ class=name>nostromo</a><nav><a href=/blog/ >Blog</a></nav></header><main><p id=published><time datetime=2025-08-17>2025-08-17</time></p><h1 class=title>Exploiting a 40 year-old design choice to speed up vector search</h1><blockquote id=description></blockquote><nav><ul><li><a href=#background>Rust, <code class=scode>f32</code>, <code class=scode>Ord</code>, and sadness</a></li><li><a href=#ieee>Getting sneaky with IEEE 754</a></li><li><a href=#custom-ordered-float>Ordering your own floats</a></li><li><a href=#benches>Benchmark</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav><div class=md-body><p>A while ago, I came across a post on reddit about a user’s experience <a href=https://ohadravid.github.io/posts/2025-05-rav1d-faster/ >speeding up the rav1d video decoder by 1%</a>, which inspired me to try a similar trick to speed up sorting <code class=scode>f32</code>’s in <a href=https://github.com/nnethercott/hannoy>my vector database</a>.</p><p>The hack from the post involved swapping <em>field-wise</em> equality for <em>byte-wise</em> equality, which translated into a custom impl of <code class=scode>PartialEq</code> for the struct in question. Doing this greatly reduced the number of instructions in the resulting assembly code by almost half and yielded tangible speedups in the decoder.</p><p>So instead of this :</p><pre class=scode><code><span class="srust ssource"><span class="srust skeyword sother">use</span> <span class="srust smeta spath">zerocopy<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>AsBytes</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>

<span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sannotation svariable">derive</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">PartialEq<span class="srust spunctuation sseparator">,</span> AsBytes</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sannotation svariable">repr</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">C</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sstruct"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust sentity sname sstruct">Foo</span></span><span class="srust smeta sstruct"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
  <span class="srust svariable smember sother">a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">i32</span>,
  <span class="srust svariable smember sother">b</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">i32</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>You’d write :</p><pre class=scode><code><span class="srust ssource"><span class="srust skeyword sother">use</span> <span class="srust smeta spath">zerocopy<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>AsBytes</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>

<span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sannotation svariable">derive</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">AsBytes</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sannotation svariable">repr</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">C</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sstruct"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust sentity sname sstruct">Foo</span></span><span class="srust smeta sstruct"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
  <span class="srust svariable smember sother">a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">i32</span>,
  <span class="srust svariable smember sother">b</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">i32</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">PartialEq <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">Foo</span></span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
  <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">eq</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">other</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage stype">Self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust sstorage stype">bool</span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
    <span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> NOTE: `as_bytes` comes from #[derive(AsBytes)]
</span>    <span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">as_bytes</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>  <span class="srust skeyword soperator">=</span><span class="srust skeyword soperator">=</span> other.<span class="srust sfunction ssupport">as_bytes</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
  </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Now when we consider the equality of two <code class=scode>&Foo</code>’s we just look at <code class=scode>&[u8]</code> slices instead of doing a field-by-field check.</p><p>In vector search applications, a non-negligeable amount of time is spent ordering <code class=scode>f32</code>’s to determine if an item is a nearest neighbour or not. I figured it was the perfect setting to try out the approach above.</p><h2 id=background><a href=#background class=anchor></a>Rust, <code class=scode>f32</code>, <code class=scode>Ord</code>, and sadness</h2><p>In rust, <code class=scode>f32</code> doesn’t implement <code class=scode>Ord</code> or <code class=scode>Eq</code>. Consulting the docs on <a href=https://doc.rust-lang.org/std/primitive.f32.html#nan-bit-patterns>NaN’s</a> explains why :</p><blockquote><ul><li>It is not equal to any float, including itself! This is the reason f32 doesn’t implement the Eq trait.</li><li>It is also neither smaller nor greater than any float, making it impossible to sort by the default comparison operation, which is the reason f32 doesn’t implement the Ord trait. <a href=https://doc.rust-lang.org/std/primitive.f32.html>[link]</a></li></ul></blockquote><p>This is why you need a crate like <a href=https://docs.rs/ordered-float/latest/ordered_float/ >ordered-float</a> if you wish to work with containers like <code class=scode>std::collections::BinaryHeap&lt;T></code> that enforces the <code class=scode>T: Ord</code> trait bound to perform sorting internally.</p><p><code class=scode>ordered-float</code> is great most of the time, but in the context of vector search I think it’s a bit overkill.</p><p>For starters, we’re only working with <em>non-negative</em> <code class=scode>f32</code>’s coming from <a href=https://en.wikipedia.org/wiki/Metric_space#Definition>distance metrics</a>, not the whole representable range. For another, the <code class=scode>ordered-float</code> crate also implements <code class=scode>Hash</code> for it’s <code class=scode>OrderedFloat&lt;f32></code> wrapper type which adds some lines of code to the final executable that we don’t really need.</p><p>On top of this, the project itself is around ~3k SLOC, while a <a href=https://github.com/nnethercott/hannoy/blob/main/src/ordered_float.rs>bare-bones implementation doing only what we need</a> takes less than 50 SLOC.</p><h2 id=ieee><a href=#ieee class=anchor></a>Getting sneaky with IEEE 754</h2><p>Floats are generally made up of 3 components: a sign bit; some exponent bits; and some mantissa (fraction) bits. This format goes all the way back to the <a href=https://en.wikipedia.org/wiki/IEEE_754>IEEE 754 Standard</a> from 1985, and is what’s going to help us here today.</p><p>By playing around with the number of bits you allocate between the exponent and mantissa you can cover a wider <a href=https://en.wikipedia.org/wiki/Dynamic_range>dynamic range</a> or achieve higher precision depending on your use-case. <code class=scode>bf16</code> for instance allocates fewer fraction bits while maintaining the same number of exponent bits as <code class=scode>f32</code>, making it less precise but covering the same dynamic range.</p><figure><div style=text-align:center><img src=/static/images/f32_post/f32_754.png style="padding:1em;width:100%;display:block;margin:0 auto"><figcaption>Bit-layout of an f32 <a href=https://en.wikipedia.org/wiki/Single-precision_floating-point_format>[1]</a></figcaption></div></figure><p>To convert from a 32-bit integer back to an <code class=scode>f32</code> you use the following formula: $$ x = (-1)^{\text{sign}}\times2^{(\text{exponent}-127)}\times\left(1+\sum_{i=1}^{23}b^{(fraction)}_{i}2^{-i} \right) $$</p><p>While it may be true that $-x\leq x$ in <code class=scode>f32</code>-world, the same relationship doesn’t hold when we interpret those same <code class=scode>f32</code>’s as <code class=scode>u32</code>’s. It’s enough to look at the sign bit and see why; any negative number has the most significant bit set to 1 which automatically makes it larger as an integer than its positive counterpart.</p><p>This is why statements like <code class=scode>(f32::MAX).to_bits()</code> &lt; <code class=scode>(-0.0f32).to_bits()</code> evaluate to <code class=scode>true</code>.</p><p>Ok, so we can’t just compare <code class=scode>&[u8]</code>’s and call it a day… <em>or can we ?</em></p><p>Recall that all the <code class=scode>f32</code>’s we need to sort come from distance calculations (e.g. cosine, euclidean, hamming, etc.) so we can guarantee that they’re always $\geq 0$ ! <strong>This means it’s totally valid to compare the <code class=scode>f32</code>’s as if they were integers</strong>.</p><p>The only edge case we really need to look out for is a <code class=scode>-0.0f32</code> showing up from float arithmetic, but we can add an assert to filter cases like these out.</p><h2 id=custom-ordered-float><a href=#custom-ordered-float class=anchor></a>Ordering your own floats</h2><p>I’ll be honest, the code I’m about to share is pretty underwhelming, it’s exactly what you’d expect if you’ve been reading along so far. But hey, it works !</p><p>Here it is :</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sannotation svariable">derive</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">Default<span class="srust spunctuation sseparator">,</span> Debug<span class="srust spunctuation sseparator">,</span> Clone<span class="srust spunctuation sseparator">,</span> Copy</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sstruct"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust sentity sname sstruct">OrderedFloat</span></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span>pub <span class="srust sstorage stype">f32</span></span><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">PartialEq <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">OrderedFloat</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
    <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">eq</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">other</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage stype">Self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust sstorage stype">bool</span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
        <span class="srust svariable slanguage">self</span>.<span class="srust sconstant sfloat snumeric">0.</span><span class="srust sfunction ssupport">to_bits</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">eq</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>other.<span class="srust sconstant sfloat snumeric">0.</span><span class="srust sfunction ssupport">to_bits</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
    </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">Eq <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">OrderedFloat</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">PartialOrd <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">OrderedFloat</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
    <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">partial_cmp</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">other</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage stype">Self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath">std<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta spath">cmp<span class="srust spunctuation saccessor">::</span></span>Ordering<span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
        <span class="srust ssupport stype">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">cmp</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span>other</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
    </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">Ord <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">OrderedFloat</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
    <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">cmp</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">other</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage stype">Self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta spath">std<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta spath">cmp<span class="srust spunctuation saccessor">::</span></span>Ordering</span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
        <span class="srust svariable slanguage">self</span>.<span class="srust sconstant sfloat snumeric">0.</span><span class="srust sfunction ssupport">to_bits</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">cmp</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>other.<span class="srust sconstant sfloat snumeric">0.</span><span class="srust sfunction ssupport">to_bits</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
    </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>This struct does everything we need; no more, no less !</p><p>Note that we <em>should</em> add some kind of check in the constructor to ensure our <code class=scode>OrderedFloat</code> isn’t being built with a negative number, but for the sake of this blog post I’ll skip that.</p><h2 id=benches><a href=#benches class=anchor></a>Benchmark</h2><p>Recall that way back at the start of this post I stated the goal was to see if comparing <code class=scode>f32</code>’s <em>byte-wise</em> was faster doing “proper”<code class=scode>f32</code> comparisons. Well let’s do that.</p><p>We’ll benchmark how long it takes to build a <code class=scode>BinaryHeap</code> from both my <code class=scode>OrderedFloat</code> and the <code class=scode>ordered_float::OrderedFloat::&lt;f32></code>.</p><blockquote><p>As an aside, I recently switched from <a href=https://github.com/bheisler/criterion.rs>criterion</a> to <a href=https://github.com/nvzqz/divan>divan</a> for benchmarking due to it’s simple and expressive syntax, and I’ve gotta say I’ve been loving it ! 🎉</p></blockquote><details><summary>Click here to expand the benchmarking code</summary><pre class=scode><code><span class="srust ssource"><span class="srust skeyword sother">use</span> <span class="srust smeta spath">std<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta spath">collections<span class="srust spunctuation saccessor">::</span></span>BinaryHeap<span class="srust spunctuation sterminator">;</span>

<span class="srust skeyword sother">use</span> <span class="srust smeta spath">divan<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span><span class="srust svariable slanguage">self</span><span class="srust spunctuation sseparator">,</span> Bencher<span class="srust spunctuation sseparator">,</span> <span class="srust smeta spath">counter<span class="srust spunctuation saccessor">::</span></span>BytesCount</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust skeyword sother">use</span> <span class="srust smeta spath">f32_blogpost_bench<span class="srust spunctuation saccessor">::</span></span>OrderedFloat<span class="srust spunctuation sterminator">;</span>
<span class="srust skeyword sother">use</span> <span class="srust smeta spath">rand<span class="srust spunctuation saccessor">::</span></span>Rng<span class="srust spunctuation sterminator">;</span>

<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">main</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
    <span class="srust smeta spath">divan<span class="srust spunctuation saccessor">::</span></span>main<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sannotation svariable">divan</span>::<span class="srust sannotation svariable">bench</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">consts <span class="srust skeyword soperator">=</span> [10<span class="srust spunctuation sseparator">,</span> 100<span class="srust spunctuation sseparator">,</span> 1000<span class="srust spunctuation sseparator">,</span> 10000]</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">custom_ord_impl</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>const N<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">bencher</span><span class="srust spunctuation sseparator">:</span> Bencher</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
    bencher
        .<span class="srust sfunction ssupport">with_inputs</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">|</span></span></span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">|</span></span> </span><span class="srust smeta sfunction sclosure"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
            <span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> nums <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sstorage stype">f32</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>default<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">;</span> N<span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
            <span class="srust smeta spath">rand<span class="srust spunctuation saccessor">::</span></span>rng<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">fill</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> nums</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
            <span class="srust sstorage stype">let</span> nums_cmp<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Result<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Vec<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span>, <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'static</span> <span class="srust sstorage stype">str</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span>
                nums.<span class="srust sfunction ssupport">into_iter</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust smeta spath">OrderedFloat<span class="srust spunctuation saccessor">::</span></span>try_from</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">collect</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>

            nums_cmp.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
        </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
        .<span class="srust sfunction ssupport">bench_values</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">|</span></span></span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust svariable sparameter">vec</span><span class="srust spunctuation ssection send sparameters">|</span></span> </span><span class="srust smeta sfunction sclosure"><span class="srust smeta spath">BinaryHeap<span class="srust spunctuation saccessor">::</span></span>from<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span>vec</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sannotation svariable">divan</span>::<span class="srust sannotation svariable">bench</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">consts <span class="srust skeyword soperator">=</span> [10<span class="srust spunctuation sseparator">,</span> 100<span class="srust spunctuation sseparator">,</span> 1000<span class="srust spunctuation sseparator">,</span> 10000]</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">ordered_float_crate</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>const N<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">bencher</span><span class="srust spunctuation sseparator">:</span> Bencher</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
    bencher
        .<span class="srust sfunction ssupport">with_inputs</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">|</span></span></span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">|</span></span> </span><span class="srust smeta sfunction sclosure"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
            <span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> nums <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sstorage stype">f32</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>default<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">;</span> N<span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
            <span class="srust smeta spath">rand<span class="srust spunctuation saccessor">::</span></span>rng<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">fill</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> nums</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
            <span class="srust sstorage stype">let</span> nums_cmp<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Vec<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> nums
                .<span class="srust sfunction ssupport">into_iter</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
                .<span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust smeta spath">ordered_float<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta spath">OrderedFloat<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">f32</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
                .<span class="srust sfunction ssupport">collect</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>

            nums_cmp
        </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
        .<span class="srust sfunction ssupport">bench_values</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">|</span></span></span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust svariable sparameter">vec</span><span class="srust spunctuation ssection send sparameters">|</span></span> </span><span class="srust smeta sfunction sclosure"><span class="srust smeta spath">BinaryHeap<span class="srust spunctuation saccessor">::</span></span>from<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span>vec</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre></details><figure><div style=text-align:center><img src=/static/images/f32_post/divan.png style="padding:1em;width:100%;display:block;margin:0 auto"></div></figure><p>As you can see, by comparing <code class=scode>f32</code>s via their <code class=scode>&[u8]</code> representation we’re able to fill a <code class=scode>BinaryHeap</code> twice as quickly on average!</p><h2 id=conclusion><a href=#conclusion class=anchor></a>Conclusion</h2><p>I’ll be the first to admit that these speedups are relatively small when you consider that <a href=https://qdrant.tech/benchmarks/ >a typical search usually takes O(10ms)</a>, but I find it intellectually satisfying that we were able to leverage the structure of our data to squeeze out some speed gains.</p><p>To summarize everything, in this article we exploited both the fact that <code class=scode>f32</code>’s coming from distance calculations are never negative, as well the 32-bit layout of a single-precision float, in order to compare <code class=scode>f32</code>’s more efficiently.</p><figure><div style=text-align:center><img src=/static/images/f32_post/flame.png style="padding:1em;width:100%;display:block;margin:0 auto"><figcaption>Vector search in hannoy is currently dominated by SIMD and LMDB lookups.</figcaption></div></figure><p>There’s still <em>much</em> work to be done to speed up the vector db further, but we take speedups where we can get them :)</p></div><p class=back><a href=#>⮬ Back to top</a></p></main></body></html>