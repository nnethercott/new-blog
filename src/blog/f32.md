{
	"published": "2025-08-17",
  "description": ""
}

# Exploiting a 40 year-old design choice to speed up vector search

A while ago, I came across a post on Reddit about a user's experience [speeding up the rav1d video decoder](https://ohadravid.github.io/posts/2025-05-rav1d-faster/) and got inspired by a simple trick they used to eke out a ~1% improvement.

The hack involved replacing field-wise equality with byte-wise equality for a struct which translated in code as a custom impl of `PartialEq`. Doing it this way greatly reduces the number of instructions in the resulting assembly code by almost half.

So instead of this :
```rust

use zerocopy::{AsBytes}

#[derive(PartialEq, AsBytes)]
#[repr(C)]
pub struct Foo{
  a: i32,
  b: i32
}
```

You write this :

```rust

use zerocopy::{AsBytes}

#[derive(AsBytes)]
#[repr(C)]
pub struct Foo{
  a: i32,
  b: i32
}

impl PartialEq for Foo{
  fn eq(&self, other: &Self) -> bool {
    // `as_bytes` comes from #[derive(AsBytes)]
    self.as_bytes()  == other.as_bytes()
  }
}
```


At the time, I was writing [a vector database](https://github.com/nnethercott/hannoy) in which a significant amount of time is spent comparing distances represented as `f32`'s to determine if an item is a nearest neighbour or not. I figured it was the perfect setting to try it out.


## Rust, `f32`, `PartialEq`, and sadness {#background}
In rust, `f32` doesn't implement `PartialEq` by default since. Reading [the docs for f32](https://doc.rust-lang.org/std/primitive.f32.html) we find that
